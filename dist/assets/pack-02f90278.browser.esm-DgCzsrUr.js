const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CRXhB-tn.js","assets/index-C5opNnue.css"])))=>i.map(i=>d[i]);
import{Z as P,$ as f,a0 as g,a1 as O,a2 as I,a3 as L,i as k,A as q,a4 as U,j as F,k as $,l as N,B as h,F as R,G as w,m,T as l,v as S,x,a5 as E,a6 as D,f as y,a7 as V}from"./index-CRXhB-tn.js";import{h as M}from"./hasERC20Allowance-654a940b.browser.esm-36jzYGyl.js";import{R as z,a as K}from"./assertEnabled-d1700f0b.browser.esm-CuId8uDg.js";import{C as B,a as G,G as Q,b as _,d as Y}from"./contract-appuri-5c40af52.browser.esm-iXrARNet.js";import{i as v}from"./marketplace-e3129e2f.browser.esm-BBiIxhg2.js";import{u as j}from"./QueryParams-32a56510.browser.esm-CJ0DYI-a.js";import{C as J}from"./contract-interceptor-d7b164a7.browser.esm-C_yNedqZ.js";import{C as Z,a as H}from"./contract-owner-49e75547.browser.esm-BuMVgBnJ.js";import{C as X}from"./contract-roles-71988d2e.browser.esm-CBnW-SmK.js";import{S as tt}from"./erc-1155-standard-a5888d37.browser.esm-B2RKOe5t.js";import{E as et}from"./erc-20-9a18a51c.browser.esm-DlwhiCEF.js";import{N as rt}from"./setErc20Allowance-7f76f677.browser.esm-DleMWaY1.js";import"./index-CD3KUISV.js";import"./erc-1155-7ce9bee1.browser.esm-DsYxGXv7.js";import"./drop-claim-conditions-e6f2abbf.browser.esm-Dk2Ztl9z.js";import"./treeify-BwbAlYD3.js";const A=P({contractAddress:O}),at=A.extend({quantity:I}),nt=A.extend({tokenId:g}),st=A.extend({tokenId:g,quantity:g}),ot=at.omit({quantity:!0}).extend({quantityPerReward:I}),ct=nt,dt=st.omit({quantity:!0}).extend({quantityPerReward:g}),it=ot.extend({totalRewards:g.default("1")}),pt=ct,ut=dt.extend({totalRewards:g.default("1")}),T=P({erc20Rewards:f(it).default([]),erc721Rewards:f(pt).default([]),erc1155Rewards:f(ut).default([])}),ht=T.extend({packMetadata:rt,rewardsPerPack:g.default("1"),openStartTime:z.default(new Date)});class gt{featureName=E.name;constructor(t,e,a,n,s){let o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:new k(t,e,D,n,a);this.contractWrapper=o,this.storage=a,this.chainId=s,this.events=new _(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}open=m((()=>{var t=this;return async function(e){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:5e5;return l.fromContractWrapper({contractWrapper:t.contractWrapper,method:"openPack",args:[e,a],overrides:{gasLimit:n},parse:s=>{let o=h.from(0);try{o=t.contractWrapper.parseLogs("PackOpenRequested",s?.logs)[0].args.requestId}catch{}return{receipt:s,id:o}}})}})());claimRewards=m((()=>{var t=this;return async function(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:5e5;return l.fromContractWrapper({contractWrapper:t.contractWrapper,method:"claimRewards",args:[],overrides:{gasLimit:e},parse:async a=>{const n=t.contractWrapper.parseLogs("PackOpened",a?.logs);if(n.length===0)throw new Error("PackOpened event not found");const s=n[0].args.rewardUnitsDistributed;return await t.parseRewards(s)}})}})());async parseRewards(t){const e=[],a=[],n=[];for(const s of t)switch(s.tokenType){case 0:{const o=await R(this.contractWrapper.getProvider(),s.assetContract);e.push({contractAddress:s.assetContract,quantityPerReward:w(s.totalAmount,o.decimals).toString()});break}case 1:{a.push({contractAddress:s.assetContract,tokenId:s.tokenId.toString()});break}case 2:{n.push({contractAddress:s.assetContract,tokenId:s.tokenId.toString(),quantityPerReward:s.totalAmount.toString()});break}}return{erc20Rewards:e,erc721Rewards:a,erc1155Rewards:n}}async addPackOpenEventListener(t){return this.events.addEventListener("PackOpened",async e=>{t(e.data.packId.toString(),e.data.opener,await this.parseRewards(e.data.rewardUnitsDistributed))})}async canClaimRewards(t){const e=await S(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("canClaimRewards",[e])}async openAndClaim(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1,a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:5e5;const n=await this.contractWrapper.sendTransaction("openPackAndClaimRewards",[t,e,a],{gasLimit:h.from(5e5)});let s=h.from(0);try{s=this.contractWrapper.parseLogs("PackOpenRequested",n?.logs)[0].args.requestId}catch{}return{receipt:n,id:s}}async getLinkBalance(){const t=(await y(async()=>{const{default:e}=await import("./index-CRXhB-tn.js").then(a=>a.eJ);return{default:e}},__vite__mapDeps([0,1]))).default;return this.getLinkContract(t).balanceOf(this.contractWrapper.address)}async transferLink(t){const e=(await y(async()=>{const{default:a}=await import("./index-CRXhB-tn.js").then(n=>n.eJ);return{default:a}},__vite__mapDeps([0,1]))).default;await this.getLinkContract(e).transfer(this.contractWrapper.address,t)}getLinkContract(t){const e=V[this.chainId];if(!e)throw new Error(`No LINK token address found for chainId ${this.chainId}`);const a=new k(this.contractWrapper.getSignerOrProvider(),e,t,this.contractWrapper.options,this.storage);return new et(a,this.storage,this.chainId)}}class b extends tt{static contractRoles=L;get vrf(){return K(this._vrf,E)}constructor(t,e,a){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0,d=arguments.length>6&&arguments[6]!==void 0?arguments[6]:new k(t,e,s,n.gasless&&"openzeppelin"in n.gasless?{...n,gasless:{...n.gasless,openzeppelin:{...n.gasless.openzeppelin,useEOAForwarder:!0}}}:n,a);super(d,a,o),this.abi=q.parse(s||[]),this.metadata=new B(this.contractWrapper,U,this.storage),this.app=new G(this.contractWrapper,this.metadata,this.storage),this.roles=new X(this.contractWrapper,b.contractRoles),this.royalties=new Z(this.contractWrapper,this.metadata),this.encoder=new F(this.contractWrapper),this.estimator=new Q(this.contractWrapper),this.events=new _(this.contractWrapper),this.interceptor=new J(this.contractWrapper),this.owner=new H(this.contractWrapper),this._vrf=this.detectVrf()}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t),this._vrf?.onNetworkUpdated(t)}getAddress(){return this.contractWrapper.address}async get(t){return this.erc1155.get(t)}async getAll(t){return this.erc1155.getAll(t)}async getOwned(t){return this.erc1155.getOwned(t)}async getTotalCount(){return this.erc1155.totalCount()}async isTransferRestricted(){return!await this.contractWrapper.read("hasRole",[$("transfer"),N])}async getPackContents(t){const{contents:e,perUnitAmounts:a}=await this.contractWrapper.read("getPackContents",[t]),n=[],s=[],o=[];for(let d=0;d<e.length;d++){const c=e[d],r=a[d];switch(c.tokenType){case 0:{const p=await R(this.contractWrapper.getProvider(),c.assetContract),i=w(r,p.decimals),u=w(h.from(c.totalAmount).div(r),p.decimals);n.push({contractAddress:c.assetContract,quantityPerReward:i,totalRewards:u});break}case 1:{s.push({contractAddress:c.assetContract,tokenId:c.tokenId.toString()});break}case 2:{o.push({contractAddress:c.assetContract,tokenId:c.tokenId.toString(),quantityPerReward:r.toString(),totalRewards:h.from(c.totalAmount).div(r).toString()});break}}}return{erc20Rewards:n,erc721Rewards:s,erc1155Rewards:o}}create=m(async t=>{const e=await this.contractWrapper.getSignerAddress();return this.createTo.prepare(e,t)});addPackContents=m(async(t,e)=>{const[a,n]=await Promise.all([this.contractWrapper.getSignerAddress(),T.parseAsync(e)]),{contents:s,numOfRewardUnits:o}=await this.toPackContentArgs(n);return l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"addPackContents",args:[t,s,o,a],parse:d=>{const c=this.contractWrapper.parseLogs("PackUpdated",d?.logs);if(c.length===0)throw new Error("PackUpdated event not found");const r=c[0].args.packId;return{id:r,receipt:d,data:()=>this.erc1155.get(r)}}})});createTo=m(async(t,e)=>{const[a,n,s]=await Promise.all([j(e.packMetadata,this.storage),ht.parseAsync(e),S(t)]),{erc20Rewards:o,erc721Rewards:d,erc1155Rewards:c}=n,r={erc20Rewards:o,erc721Rewards:d,erc1155Rewards:c},{contents:p,numOfRewardUnits:i}=await this.toPackContentArgs(r);return l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createPack",args:[p,i,a,n.openStartTime,n.rewardsPerPack,s],parse:u=>{const C=this.contractWrapper.parseLogs("PackCreated",u?.logs);if(C.length===0)throw new Error("PackCreated event not found");const W=C[0].args.packId;return{id:W,receipt:u,data:()=>this.erc1155.get(W)}}})});open=m((()=>{var t=this;return async function(e){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:5e5;if(t._vrf)throw new Error("This contract is using Chainlink VRF, use `contract.vrf.open()` or `contract.vrf.openAndClaim()` instead");return l.fromContractWrapper({contractWrapper:t.contractWrapper,method:"openPack",args:[e,a],overrides:{gasLimit:n},parse:async s=>{const o=t.contractWrapper.parseLogs("PackOpened",s?.logs);if(o.length===0)throw new Error("PackOpened event not found");const d=o[0].args.rewardUnitsDistributed,c=[],r=[],p=[];for(const i of d)switch(i.tokenType){case 0:{const u=await R(t.contractWrapper.getProvider(),i.assetContract);c.push({contractAddress:i.assetContract,quantityPerReward:w(i.totalAmount,u.decimals).toString()});break}case 1:{r.push({contractAddress:i.assetContract,tokenId:i.tokenId.toString()});break}case 2:{p.push({contractAddress:i.assetContract,tokenId:i.tokenId.toString(),quantityPerReward:i.totalAmount.toString()});break}}return{erc20Rewards:c,erc721Rewards:r,erc1155Rewards:p}}})}})());async toPackContentArgs(t){const e=[],a=[],{erc20Rewards:n,erc721Rewards:s,erc1155Rewards:o}=t,d=this.contractWrapper.getProvider(),c=await this.contractWrapper.getSignerAddress();for(const r of n){const i=(await x(d,r.quantityPerReward,r.contractAddress)).mul(r.totalRewards);if(!await M(this.contractWrapper,r.contractAddress,i))throw new Error(`ERC20 token with contract address "${r.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${r.contractAddress}").setAllowance("${this.getAddress()}", ${i});

`);a.push(r.totalRewards),e.push({assetContract:r.contractAddress,tokenType:0,totalAmount:i,tokenId:0})}for(const r of s){if(!await v(this.contractWrapper.getProvider(),this.getAddress(),r.contractAddress,r.tokenId,c))throw new Error(`ERC721 token "${r.tokenId}" with contract address "${r.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${r.contractAddress}").setApprovalForToken("${this.getAddress()}", ${r.tokenId});

`);a.push("1"),e.push({assetContract:r.contractAddress,tokenType:1,totalAmount:1,tokenId:r.tokenId})}for(const r of o){if(!await v(this.contractWrapper.getProvider(),this.getAddress(),r.contractAddress,r.tokenId,c))throw new Error(`ERC1155 token "${r.tokenId}" with contract address "${r.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${r.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);a.push(r.totalRewards),e.push({assetContract:r.contractAddress,tokenType:2,totalAmount:h.from(r.quantityPerReward).mul(h.from(r.totalRewards)),tokenId:r.tokenId})}return{contents:e,numOfRewardUnits:a}}async prepare(t,e,a){return l.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:a})}async call(t,e,a){return this.contractWrapper.call(t,e,a)}detectVrf(){if(Y(this.contractWrapper,"PackVRF"))return new gt(this.contractWrapper.getSignerOrProvider(),this.contractWrapper.address,this.storage,this.contractWrapper.options,this.chainId)}}export{b as Pack};
