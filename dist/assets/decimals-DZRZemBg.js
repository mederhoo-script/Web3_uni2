import{dz as M,dA as z,dB as j,dC as x,dD as P,dE as _,dF as D,dG as B,dH as w,dI as L,dJ as q,dK as k,dL as V,dM as v,dN as F,dO as W,dP as H,dQ as C,dR as J}from"./index-CRXhB-tn.js";const Y=new Map,K=new Map;function Z(e){const t=(i,o)=>({clear:()=>o.delete(i),get:()=>o.get(i),set:r=>o.set(i,r)}),s=t(e,Y),n=t(e,K);return{clear:()=>{s.clear(),n.clear()},promise:s,response:n}}async function G(e,{cacheKey:t,cacheTime:s=Number.POSITIVE_INFINITY}){const n=Z(t),i=n.response.get();if(i&&s>0&&new Date().getTime()-i.created.getTime()<s)return i.data;let o=n.promise.get();o||(o=e(),n.promise.set(o));try{const r=await o;return n.response.set({created:new Date,data:r}),r}finally{n.promise.clear()}}async function Q(e,t,s){const n=await M(t)(e,{headers:{...t.config?.rpc?.fetch?.headers,"Content-Type":"application/json"},body:z(s.requests),method:"POST",requestTimeoutMs:s.requestTimeoutMs??t.config?.rpc?.fetch?.requestTimeoutMs,keepalive:t.config?.rpc?.fetch?.keepalive});if(!n.ok)throw n.body?.cancel(),new Error(`RPC request failed with status ${n.status} - ${n.statusText}`);if(n.headers.get("Content-Type")?.startsWith("application/json"))return await n.json();const i=await n.text();try{return JSON.parse(i)}catch(o){throw console.error("Error parsing response",o,i),o}}async function X(e,t,s){const n=await M(t)(e,{headers:{...t.config?.rpc?.fetch?.headers||{},"Content-Type":"application/json"},body:z(s.request),method:"POST",requestTimeoutMs:s.requestTimeoutMs??t.config?.rpc?.fetch?.requestTimeoutMs,keepalive:t.config?.rpc?.fetch?.keepalive});if(!n.ok)throw n.body?.cancel(),new Error(`RPC request failed with status ${n.status}`);if(n.headers.get("Content-Type")?.startsWith("application/json"))return await n.json();const i=await n.text();try{return JSON.parse(i)}catch(o){throw console.error("Error parsing response",o,i),o}}const R=new WeakMap;function ee(e){if(R.has(e))return R.get(e);const t=new Map;return R.set(e,t),t}function te(e){return`${e.method}:${JSON.stringify(e.params)}`}const se=100,ne=0;function ie(e){const t=ee(e.client),s=e.chain.id;if(t.has(e.chain.rpc))return t.get(e.chain.rpc);const n=(()=>{const i=j({client:e.client,chain:e.chain}),o=e.config?.maxBatchSize??e.client.config?.rpc?.maxBatchSize??se,r=e.config?.batchTimeoutMs??e.client.config?.rpc?.batchTimeoutMs??ne,a=new Map;let c=[],u=null;function p(){u&&(clearTimeout(u),u=null);const h=new Array(c.length),d=c.slice().map((l,f)=>(l.request.id=f,l.request.jsonrpc="2.0",h[f]=l.request,l));c=[],Q(i,e.client,{requests:h,requestTimeoutMs:e.config?.requestTimeoutMs}).then(l=>{d.forEach((f,b)=>{const y=l[b];if(!y){f.reject(new Error("No response"));return}if(y instanceof Error){f.reject(y);return}if(typeof y=="string"){f.reject(new Error(y));return}if("error"in y)f.reject(y.error);else{if(y.method==="eth_subscription")throw new Error("Subscriptions not supported yet");f.resolve(y.result)}a.delete(f.requestKey)})}).catch(l=>{for(const f of d)f.reject(l),a.delete(f.requestKey)})}return o===1?async h=>{h.id=1,h.jsonrpc="2.0";const d=await X(i,e.client,{request:h,requestTimeoutMs:e.config?.requestTimeoutMs});if(!d)throw new Error("No response");if("error"in d)throw d.error;return d.result}:async h=>{const d=te(h);if(a.has(d))return a.get(d);let l,f;const b=new Promise((y,S)=>{l=y,f=S});return a.set(d,b),c.push({request:h,resolve:l,reject:f,requestKey:d}),o>1?(u||(u=setTimeout(p,r)),c.length>=o&&p()):p(),b}})();return t.set(s,n),n}function re(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,{balance:s.balance?x(s.balance):void 0,nonce:s.nonce?x(s.nonce):void 0,code:s.code,state:s.state,stateDiff:s.stateDiff}]))}async function oe(e,t){const{blockNumber:s,blockTag:n,...i}=t,r=(s?x(s):void 0)||n||"latest";return await e({method:"eth_call",params:t.stateOverrides?[i,r,re(t.stateOverrides)]:[i,r]})}function N(e,{includeName:t=!1}={}){return e?e.map(s=>ae(s,{includeName:t})).join(t?", ":","):""}function ae(e,{includeName:t}){return e.type.startsWith("tuple")?`(${N(e.components,{includeName:t})})${e.type.slice(5)}`:e.type+(t&&e.name?` ${e.name}`:"")}class ce extends P{constructor({data:t,params:s,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`),{metaMessages:[`Params: (${N(s,{includeName:!0})})`,`Data:   ${t} (${n} bytes)`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t,this.params=s,this.size=n}}class ue extends P{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.'),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiDecodingZeroDataError"})}}class he extends P{constructor(t,{docsPath:s}){super([`Type "${t}" is not a valid decoding type.`,"Please provide a valid ABI type."].join(`
`),{docsPath:s}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiDecodingType"})}}function U(e,{dir:t="left"}={}){let s=typeof e=="string"?e.replace("0x",""):e,n=0;for(let i=0;i<s.length-1&&s[t==="left"?i:s.length-i-1].toString()==="0";i++)n++;return s=t==="left"?s.slice(n):s.slice(0,s.length-n),typeof e=="string"?(s.length===1&&t==="right"&&(s=`${s}0`),`0x${s.length%2===1?`0${s}`:s}`):s}class de extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}set(t,s){return super.set(t,s),this.maxSize&&this.size>this.maxSize&&this.delete(this.keys().next().value),this}}const E=new de(8192);function fe(e,t){if(E.has(`${e}.${t}`))return E.get(`${e}.${t}`);const s=e.substring(2).toLowerCase(),n=_(D(s),"bytes"),i=s.split("");for(let r=0;r<40;r+=2)n[r>>1]>>4>=8&&i[r]&&(i[r]=i[r].toUpperCase()),(n[r>>1]&15)>=8&&i[r+1]&&(i[r+1]=i[r+1].toUpperCase());const o=`0x${i.join("")}`;return E.set(`${e}.${t}`,o),o}function $(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}class A extends P{constructor({offset:t}){super(`Offset \`${t}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NegativeOffsetError"})}}class le extends P{constructor({length:t,position:s}){super(`Position \`${s}\` is out of bounds (\`0 < position < ${t}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PositionOutOfBoundsError"})}}class pe extends P{constructor({count:t,limit:s}){super(`Recursive read limit of \`${s}\` exceeded (recursive read count: \`${t}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RecursiveReadLimitExceededError"})}}const ye={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new pe({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new le({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new A({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new A({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const s=t??this.position;return this.assertPosition(s+e-1),this.bytes.subarray(s,s+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,e&255),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const s=this.inspectBytes(e);return this.position+=t??e,s},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function me(e,{recursiveReadLimit:t=8192}={}){const s=Object.create(ye);return s.bytes=e,s.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),s.positionReadCount=new Map,s.recursiveReadLimit=t,s}function be(e,t={}){typeof t.size<"u"&&B(e,{size:t.size});const s=w(e,t);return k(s,t)}function ge(e,t={}){let s=e;if(typeof t.size<"u"&&(B(s,{size:t.size}),s=U(s)),s.length>1||s[0]>1)throw new q(s);return!!s[0]}function m(e,t={}){typeof t.size<"u"&&B(e,{size:t.size});const s=w(e,t);return L(s,t)}function we(e,t={}){let s=e;return typeof t.size<"u"&&(B(s,{size:t.size}),s=U(s,{dir:"right"})),new TextDecoder().decode(s)}function Pe(e,t){const s=typeof t=="string"?V(t):t,n=me(s);if(v(s)===0&&e.length>0)throw new ue;if(v(t)&&v(t)<32)throw new ce({data:typeof t=="string"?t:w(t),params:e,size:v(t)});let i=0;const o=[];for(let r=0;r<e.length;++r){const a=e[r];n.setPosition(i);const[c,u]=g(n,a,{staticPosition:0});i+=u,o.push(c)}return o}function g(e,t,{staticPosition:s}){const n=$(t.type);if(n){const[i,o]=n;return ve(e,{...t,type:o},{length:i,staticPosition:s})}if(t.type==="tuple")return Ee(e,t,{staticPosition:s});if(t.type==="address")return Te(e);if(t.type==="bool")return Ce(e);if(t.type.startsWith("bytes"))return Be(e,t,{staticPosition:s});if(t.type.startsWith("uint")||t.type.startsWith("int"))return Re(e,t);if(t.type==="string")return xe(e,{staticPosition:s});throw new he(t.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const I=32,O=32;function Te(e){const t=e.readBytes(32);return[fe(w(F(t,-20))),32]}function ve(e,t,{length:s,staticPosition:n}){if(!s){const r=m(e.readBytes(O)),a=n+r,c=a+I;e.setPosition(a);const u=m(e.readBytes(I)),p=T(t);let h=0;const d=[];for(let l=0;l<u;++l){e.setPosition(c+(p?l*32:h));const[f,b]=g(e,t,{staticPosition:c});h+=b,d.push(f)}return e.setPosition(n+32),[d,32]}if(T(t)){const r=m(e.readBytes(O)),a=n+r,c=[];for(let u=0;u<s;++u){e.setPosition(a+u*32);const[p]=g(e,t,{staticPosition:a});c.push(p)}return e.setPosition(n+32),[c,32]}let i=0;const o=[];for(let r=0;r<s;++r){const[a,c]=g(e,t,{staticPosition:n+i});i+=c,o.push(a)}return[o,i]}function Ce(e){return[ge(e.readBytes(32),{size:32}),32]}function Be(e,t,{staticPosition:s}){const[n,i]=t.type.split("bytes");if(!i){const r=m(e.readBytes(32));e.setPosition(s+r);const a=m(e.readBytes(32));if(a===0)return e.setPosition(s+32),["0x",32];const c=e.readBytes(a);return e.setPosition(s+32),[w(c),32]}return[w(e.readBytes(Number.parseInt(i),32)),32]}function Re(e,t){const s=t.type.startsWith("int"),n=Number.parseInt(t.type.split("int")[1]||"256"),i=e.readBytes(32);return[n>48?be(i,{signed:s}):m(i,{signed:s}),32]}function Ee(e,t,{staticPosition:s}){const n=t.components.length===0||t.components.some(({name:r})=>!r),i=n?[]:{};let o=0;if(T(t)){const r=m(e.readBytes(O)),a=s+r;for(let c=0;c<t.components.length;++c){const u=t.components[c];e.setPosition(a+o);const[p,h]=g(e,u,{staticPosition:a});o+=h,i[n?c:u?.name]=p}return e.setPosition(s+32),[i,32]}for(let r=0;r<t.components.length;++r){const a=t.components[r],[c,u]=g(e,a,{staticPosition:s});i[n?r:a?.name]=c,o+=u}return[i,o]}function xe(e,{staticPosition:t}){const s=m(e.readBytes(32)),n=t+s;e.setPosition(n);const i=m(e.readBytes(32));if(i===0)return e.setPosition(t+32),["",32];const o=e.readBytes(i,32),r=we(U(o));return e.setPosition(t+32),[r,32]}function T(e){const{type:t}=e;if(t==="string"||t==="bytes"||t.endsWith("[]"))return!0;if(t==="tuple")return e.components?.some(T);const s=$(e.type);return!!(s&&T({...e,type:s[1]}))}async function Oe(e){const{contract:t,method:s,params:n}=e,i=async()=>{if(Array.isArray(s))return s;if(H(s))return C(s);if(typeof s=="function")return C(await s(t));if(typeof s=="string"&&s.startsWith("function ")){const h=J(s);if(h.type==="function")return C(h);throw new Error('"method" passed is not of type "function"')}if(t.abi&&t.abi?.length>0){const h=t.abi?.find(d=>d.type==="function"&&d.name===s);if(h)return C(h)}throw new Error(`Could not resolve method "${s}".`)},[o,r]=await Promise.all([i(),typeof n=="function"?n():n]);let a;o[1].length===0?a=o[0]:a=o[0]+W(o[1],r).slice(2);const c=ie({chain:t.chain,client:t.client}),u=await oe(c,{data:a,to:t.address}),p=Pe(o[2],u);return Array.isArray(p)&&p.length===1?p[0]:p}const Ue="0x313ce567",Ae=[],Ie=[{type:"uint8"}];async function Me(e){return Oe({contract:e.contract,method:[Ue,Ae,Ie],params:[]})}async function Ne(e){return G(()=>Me(e),{cacheKey:`${e.contract.chain.id}:${e.contract.address}:decimals`,cacheTime:Number.POSITIVE_INFINITY})}export{Ne as decimals};
