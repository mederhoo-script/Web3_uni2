const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index.es-D660UUsN.js","assets/index-CRXhB-tn.js","assets/index-C5opNnue.css"])))=>i.map(i=>d[i]);
import{W as I,_ as c,c as p,d as m,U as _,S as g,e as y,h as C,f as P,w as E}from"./index-CRXhB-tn.js";const N=new Set([1,137,10,42161,56]),v="eip155",w="wagmi.requestedChains",u="wallet_addEthereumChain",l="last-used-chain-id";class M extends I{constructor(e){super({...e,options:{isNewChainsStale:!0,...e.options}}),c(this,"id",E.walletConnect),c(this,"name","WalletConnect"),c(this,"ready",!0),c(this,"onAccountsChanged",s=>{s.length===0?this.emit("disconnect"):s[0]&&this.emit("change",{account:p(s[0])})}),c(this,"onChainChanged",async s=>{const t=Number(s),i=this.isChainUnsupported(t);await this._storage.setItem(l,String(s)),this.emit("change",{chain:{id:t,unsupported:i}})}),c(this,"onDisconnect",async()=>{await this._setRequestedChainsIds([]),await this._storage.removeItem(l),this.emit("disconnect")}),c(this,"onDisplayUri",s=>{this.emit("message",{type:"display_uri",data:s})}),c(this,"onConnect",()=>{this.emit("connect",{provider:this._provider})}),this._storage=e.options.storage,this._createProvider(),this.filteredChains=this.chains.length>50?this.chains.filter(s=>N.has(s.chainId)):this.chains,this.showWalletConnectModal=this.options.qrcode!==!1}async connect(){let{chainId:e,pairingTopic:s}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{let t=e;if(!t){const h=await this._storage.getItem(l),o=h?parseInt(h):void 0;o&&!this.isChainUnsupported(o)?t=o:t=this.filteredChains[0]?.chainId}if(!t)throw new Error("No chains found on connector.");const i=await this.getProvider();if(this.setupListeners(),i.session){await i.disconnect();const h=this.filteredChains.filter(o=>o.chainId!==t).map(o=>o.chainId);this.emit("message",{type:"connecting"}),await i.connect({pairingTopic:s,chains:[t],optionalChains:h.length>0?h:[t]}),await this._setRequestedChainsIds(this.filteredChains.map(o=>{let{chainId:f}=o;return f}))}const n=await i.enable();if(!n[0])throw new Error("No accounts found on provider.");const r=p(n[0]),a=await this.getChainId(),d=this.isChainUnsupported(a);return{account:r,chain:{id:a,unsupported:d},provider:new m(i)}}catch(t){throw/user rejected/i.test(t?.message)?new _(t):t}}async disconnect(){const e=()=>{if(!(typeof localStorage>"u"))for(const i in localStorage)i.startsWith("wc@2")&&localStorage.removeItem(i)};e();const s=await this.getProvider();(async()=>{try{await s.disconnect()}catch(i){if(!/No matching key/i.test(i.message))throw i}finally{this._removeListeners(),await this._setRequestedChainsIds([]),e()}})()}async getAccount(){const{accounts:e}=await this.getProvider();if(!e[0])throw new Error("No accounts found on provider.");return p(e[0])}async getChainId(){const{chainId:e}=await this.getProvider();return e}async getProvider(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(this._provider||await this._createProvider(),e&&await this.switchChain(e),!this._provider)throw new Error("No provider found.");return this._provider}async getSigner(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[s,t]=await Promise.all([this.getProvider({chainId:e}),this.getAccount()]);return new m(s,e).getSigner(t)}async isAuthorized(){try{const[e,s]=await Promise.all([this.getAccount(),this.getProvider()]),t=await this._isChainsStale();if(!e)return!1;if(t&&s.session){try{await s.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(e){const s=this.chains.find(t=>t.chainId===e);if(!s)throw new g(`Chain with ID: ${e}, not found on connector.`);try{const t=await this.getProvider(),i=this._getNamespaceChainsIds(),n=this._getNamespaceMethods();if(!i.includes(e)&&n.includes(u)){const a=s.explorers&&s.explorers[0],d=a?{blockExplorerUrls:[a.url]}:{};await t.request({method:u,params:[{chainId:C(s.chainId),chainName:s.name,nativeCurrency:s.nativeCurrency,rpcUrls:y(s),...d}]});const h=await this._getRequestedChainsIds();h.push(e),await this._setRequestedChainsIds(h)}return await t.request({method:"wallet_switchEthereumChain",params:[{chainId:C(e)}]}),s}catch(t){const i=typeof t=="string"?t:t?.message;throw/user rejected request/i.test(i)?new _(t):new g(t)}}async _createProvider(){return this._initProviderPromise||(this._initProviderPromise=this.initProvider()),this._initProviderPromise}async initProvider(){const{default:e,OPTIONAL_EVENTS:s,OPTIONAL_METHODS:t}=await P(async()=>{const{default:r,OPTIONAL_EVENTS:a,OPTIONAL_METHODS:d}=await import("./index.es-D660UUsN.js");return{default:r,OPTIONAL_EVENTS:a,OPTIONAL_METHODS:d}},__vite__mapDeps([0,1,2])),[i,...n]=this.filteredChains.map(r=>{let{chainId:a}=r;return a});i&&(this._provider=await e.init({showQrModal:this.showWalletConnectModal,projectId:this.options.projectId,methods:["eth_sendTransaction","personal_sign","eth_signTypedData_v4"],optionalMethods:t,optionalEvents:s,chains:[i],optionalChains:n,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.filteredChains.map(r=>[r.chainId,r.rpc[0]||""])),qrModalOptions:this.options.qrModalOptions}))}async _isChainsStale(){if(this._getNamespaceMethods().includes(u)||!this.options.isNewChainsStale)return!1;const s=await this._getRequestedChainsIds(),t=this.filteredChains.map(n=>{let{chainId:r}=n;return r}),i=this._getNamespaceChainsIds();return i.length&&!i.some(n=>t.includes(n))?!1:!t.every(n=>s.includes(n))}async setupListeners(){this._provider&&(this._removeListeners(),this._provider.on("accountsChanged",this.onAccountsChanged),this._provider.on("chainChanged",this.onChainChanged),this._provider.on("disconnect",this.onDisconnect),this._provider.on("session_delete",this.onDisconnect),this._provider.on("display_uri",this.onDisplayUri),this._provider.on("connect",this.onConnect))}_removeListeners(){this._provider&&(this._provider.removeListener("accountsChanged",this.onAccountsChanged),this._provider.removeListener("chainChanged",this.onChainChanged),this._provider.removeListener("disconnect",this.onDisconnect),this._provider.removeListener("session_delete",this.onDisconnect),this._provider.removeListener("display_uri",this.onDisplayUri),this._provider.removeListener("connect",this.onConnect))}async _setRequestedChainsIds(e){await this._storage.setItem(w,JSON.stringify(e))}async _getRequestedChainsIds(){const e=await this._storage.getItem(w);return e?JSON.parse(e):[]}_getNamespaceChainsIds(){return this._provider?this._provider.session?.namespaces[v]?.chains?.map(s=>parseInt(s.split(":")[1]||""))??[]:[]}_getNamespaceMethods(){return this._provider?this._provider.session?.namespaces[v]?.methods??[]:[]}}export{M as WalletConnectConnector};
